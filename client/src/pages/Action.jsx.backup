import React, { useState, useEffect } from 'react';
// import { useNavigate } from 'react-router-dom'; // Not used in this component
import './Action.css';

const Action = () => {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [filter, setFilter] = useState('pending'); // 'pending', 'assigned', 'verified', 'done'
  const [verifying, setVerifying] = useState(new Set());

  useEffect(() => {
    loadProblems();
  }, []);

  const loadProblems = async () => {
    setLoading(true);
    try {
      console.log('üöÄ Loading problems for NGO actions...');
      const token = localStorage.getItem('token');

      if (!token) {
        setError('Please log in to view NGO actions');
        setLoading(false);
        return;
      }

      const response = await fetch('http://localhost:5001/api/problems', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to load problems: ${response.status}`);
      }

      const data = await response.json();
      console.log('‚úÖ Problems loaded for NGO:', data.length);

      // Get locally modified problems from localStorage
      const localModifications = JSON.parse(localStorage.getItem('problemModifications') || '{}');

      // Apply local modifications to server data
      const modifiedData = data.map(problem => {
        if (localModifications[problem._id]) {
          console.log(`üîÑ Applying local modification for problem ${problem._id}:`, localModifications[problem._id]);
          return { ...problem, ...localModifications[problem._id] };
        }
        return problem;
      });

      setProblems(modifiedData);
    } catch (err) {
      console.error('‚ùå Failed to load problems:', err);
      setError('Failed to load problems. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  const handleAssignStaff = async (problemId) => {
    console.log('üöÄ Assigning problem:', problemId);

    if (assigning.has(problemId)) return;

    setAssigning(prev => new Set(prev).add(problemId));

    try {
      // Update local state immediately - this is what moves the problem to assigned section
      setProblems(prev => {
        const updatedProblems = prev.map(problem =>
          problem._id === problemId
            ? { ...problem, status: 'assigned' }
            : problem
        );
        console.log('‚úÖ Problem moved to assigned section');
        return updatedProblems;
      });

      // Save local modification to localStorage for persistence
      const localModifications = JSON.parse(localStorage.getItem('problemModifications') || '{}');
      localModifications[problemId] = { status: 'assigned' };
      localStorage.setItem('problemModifications', JSON.stringify(localModifications));
      console.log('üíæ Saved local modification for problem:', problemId);

      // Optional: Try to update server in background
      const token = localStorage.getItem('token');
      if (token) {
        fetch(`http://localhost:5001/api/problems/${problemId}/assign`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        }).catch(err => console.log('Server update failed:', err.message));
      }

    } catch (err) {
      console.error('Error:', err);
    } finally {
      setAssigning(prev => {
        const newSet = new Set(prev);
        newSet.delete(problemId);
        return newSet;
      });
    }
  };

  const handleMarkAsDone = async (problemId) => {
    if (markingDone.has(problemId)) return; // Prevent multiple clicks

    setMarkingDone(prev => new Set(prev).add(problemId));

    try {
      const token = localStorage.getItem('token');
      // First verify the problem if not already verified
      const verifyResponse = await fetch(`http://localhost:5001/api/problems/${problemId}/verify`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!verifyResponse.ok) {
        throw new Error('Failed to verify problem');
      }

      // Then mark as done by submitting to government
      const submitResponse = await fetch(`http://localhost:5001/api/problems/${problemId}/submit`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!submitResponse.ok) {
        throw new Error('Failed to mark as done');
      }

      const updatedProblem = await submitResponse.json();
      console.log('‚úÖ Problem marked as done:', updatedProblem);

      // Update local state immediately for better UX
      setProblems(prev => {
        const updatedProblems = prev.map(problem =>
          problem._id === problemId
            ? { ...problem, status: 'done' }
            : problem
        );
        console.log('üìä Updated problems count after marking as done:', {
          total: updatedProblems.length,
          pending: updatedProblems.filter(p => p.status === 'pending').length,
          assigned: updatedProblems.filter(p => p.status === 'assigned').length,
          verified: updatedProblems.filter(p => p.status === 'verified').length,
          done: updatedProblems.filter(p => p.status === 'done').length
        });
        return updatedProblems;
      });

      // Save local modification to localStorage for persistence
      const localModifications = JSON.parse(localStorage.getItem('problemModifications') || '{}');
      localModifications[problemId] = { status: 'done' };
      localStorage.setItem('problemModifications', JSON.stringify(localModifications));
      console.log('üíæ Saved local modification for problem:', problemId);

      // Then fetch updated problems from server
      loadProblems();
    } catch (err) {
      console.error('‚ùå Failed to mark as done:', err);
      alert('Failed to mark as done. Please try again.');
    } finally {
      setMarkingDone(prev => {
        const newSet = new Set(prev);
        newSet.delete(problemId);
        return newSet;
      });
    }
  };

  const handleVerify = async (problemId) => {
    console.log('üöÄ Verifying problem:', problemId);

    if (verifying.has(problemId)) return;

    setVerifying(prev => new Set(prev).add(problemId));

    try {
      // Ask user to upload a photo
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.capture = 'environment'; // Use camera on mobile

      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) {
          setVerifying(prev => {
            const newSet = new Set(prev);
            newSet.delete(problemId);
            return newSet;
          });
          return;
        }

        console.log('üì∏ Photo selected:', file.name);

        // Create FormData for file upload
        const formData = new FormData();
        formData.append('verificationImage', file);

        const token = localStorage.getItem('token');

        try {
          const response = await fetch(`http://localhost:5001/api/problems/${problemId}/verify`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`
            },
            body: formData
          });

          if (!response.ok) {
            throw new Error(`Verification failed: ${response.status}`);
          }

          console.log('‚úÖ Problem verified with photo');

          // Update local state immediately
          setProblems(prev => {
            const updatedProblems = prev.map(problem =>
              problem._id === problemId
                ? { ...problem, status: 'verified' }
                : problem
            );
            console.log('‚úÖ Problem moved to verified section');
            return updatedProblems;
          });

          // Save local modification to localStorage for persistence
          const localModifications = JSON.parse(localStorage.getItem('problemModifications') || '{}');
          localModifications[problemId] = { status: 'verified' };
          localStorage.setItem('problemModifications', JSON.stringify(localModifications));
          console.log('üíæ Saved local modification for problem:', problemId);

        } catch (err) {
          console.error('‚ùå Verification failed:', err);
          alert('Failed to verify problem. Please try again.');
        } finally {
          setVerifying(prev => {
            const newSet = new Set(prev);
            newSet.delete(problemId);
            return newSet;
          });
        }
      };

      input.click();

    } catch (err) {
      console.error('Error:', err);
      setVerifying(prev => {
        const newSet = new Set(prev);
        newSet.delete(problemId);
        return newSet;
      });
    }
  };

  const getStatusBadge = (problem) => {
    switch(problem.status) {
      case 'assigned':
        return <span className="status-badge assigned">üë• Assigned to Staff</span>;
      case 'verified':
        return <span className="status-badge verified">‚úÖ Verified</span>;
      case 'sent_to_government':
        return <span className="status-badge sent">üì§ Sent to Government</span>;
      case 'done':
        return <span className="status-badge done">üèÜ Done</span>;
      case 'pending':
      default:
        return <span className="status-badge pending">‚è≥ Pending</span>;
    }
  };

    try {
      // Ask user to upload a photo
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.capture = 'environment'; // Use camera on mobile

      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) {
          setVerifying(prev => {
            const newSet = new Set(prev);
            newSet.delete(problemId);
            return newSet;
          });
          return;
        }

        console.log('üì∏ Photo selected:', file.name);

        // Create FormData for file upload
        const formData = new FormData();
        formData.append('verificationImage', file);

        const token = localStorage.getItem('token');

        try {
          const response = await fetch(`http://localhost:5001/api/problems/${problemId}/verify`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`
            },
            body: formData
          });

          if (!response.ok) {
            throw new Error(`Verification failed: ${response.status}`);
          }

          console.log('‚úÖ Problem verified with photo');

          // Update local state immediately
          setProblems(prev => {
            const updatedProblems = prev.map(problem =>
              problem._id === problemId
                ? { ...problem, status: 'verified' }
                : problem
            );
            console.log('‚úÖ Problem moved to verified section');
            return updatedProblems;
          });

          // Save local modification to localStorage for persistence
          const localModifications = JSON.parse(localStorage.getItem('problemModifications') || '{}');
          localModifications[problemId] = { status: 'verified' };
          localStorage.setItem('problemModifications', JSON.stringify(localModifications));
          console.log('üíæ Saved local modification for problem:', problemId);

        } catch (err) {
          console.error('‚ùå Verification failed:', err);
          alert('Failed to verify problem. Please try again.');
        } finally {
          setVerifying(prev => {
            const newSet = new Set(prev);
            newSet.delete(problemId);
            return newSet;
          });
        }
      };

      input.click();

    } catch (err) {
      console.error('Error:', err);
      setVerifying(prev => {
        const newSet = new Set(prev);
        newSet.delete(problemId);
        return newSet;
      });
    }
  };

  const filteredProblems = problems.filter(problem => {
    return problem.status === filter;
  });

  if (loading) return (
    <div className="action-page">
      <div className="action-container">
        <div className="loading-message">Loading NGO actions...</div>
      </div>
    </div>
  );

  if (error) return (
    <div className="action-page">
      <div className="action-container">
        <div className="error-message">{error}</div>
      </div>
    </div>
  );

  return (
    <div className="action-page">
      <div className="action-container">
        <div className="action-header">
          <h1 className="action-title">NGO Action Center</h1>
          <p className="action-subtitle">Manage community problems and coordinate with government</p>
        </div>

        <div className="action-content">
          <div className="action-filters">
            <button
              className={`filter-btn ${filter === 'pending' ? 'active' : ''}`}
              onClick={() => {
                console.log('üîÑ Switching to pending filter');
                setFilter('pending');
              }}
            >
              Pending ({problems.filter(p => p.status === 'pending').length})
            </button>
            <button
              className={`filter-btn ${filter === 'assigned' ? 'active' : ''}`}
              onClick={() => {
                console.log('üîÑ Switching to assigned filter');
                setFilter('assigned');
              }}
            >
              Assigned ({problems.filter(p => p.status === 'assigned').length})
            </button>
            <button
              className={`filter-btn ${filter === 'verified' ? 'active' : ''}`}
              onClick={() => {
                console.log('üîÑ Switching to verified filter');
                setFilter('verified');
              }}
            >
              Verified ({problems.filter(p => p.status === 'verified').length})
            </button>
            <button
              className={`filter-btn ${filter === 'done' ? 'active' : ''}`}
              onClick={() => {
                console.log('üîÑ Switching to done filter');
                setFilter('done');
              }}
            >
              Done ({problems.filter(p => p.status === 'done').length})
            </button>
          </div>

          {(() => {
            const filteredProblems = problems.filter(problem => problem.status === filter);
            console.log(`üîç Rendering ${filter} section with ${filteredProblems.length} problems:`, filteredProblems.map(p => ({ id: p._id, status: p.status, title: p.title })));

            return (
              <div className="problems-section">
                {filteredProblems.length === 0 ? (
                  <div className="no-problems">
                    <p>No problems found in this category.</p>
                  </div>
                ) : (
                  <div className="problems-grid">
                    {filteredProblems.map((problem) => (
                      <div key={problem._id} className="problem-card">
                        {problem.image && (
                          <div className="problem-image">
                            <img src={`http://localhost:5001${problem.image}`} alt={problem.title} />
                          </div>
                        )}

                        <div className="problem-content">
                          <div className="problem-header">
                            <h3 className="problem-title">{problem.title}</h3>
                            <div className="problem-location">üìç {problem.location}</div>
                          </div>

                          <p className="problem-description">{problem.description}</p>

                          <div className="problem-footer">
                            <div className="problem-meta">
                              <span className="reporter">Reported by: {problem.reporter?.username || 'Unknown'}</span>
                              <span className="date">Date: {new Date(problem.createdAt).toLocaleDateString()}</span>
                            </div>

                            <div className="problem-status-section">
                              {getStatusBadge(problem)}

                              <div className="action-buttons">
                                {problem.status === 'pending' && (
                                  <button
                                    className={`assign-staff-btn ${assigning.has(problem._id) ? 'loading' : ''}`}
                                    onClick={(e) => {
                                      e.preventDefault();
                                      e.stopPropagation();
                                      console.log('üñ±Ô∏è Assign Staff button clicked for problem:', problem._id);
                                      handleAssignStaff(problem._id);
                                    }}
                                    disabled={assigning.has(problem._id)}
                                    style={{ pointerEvents: assigning.has(problem._id) ? 'none' : 'auto', zIndex: 10 }}
                                  >
                                    {assigning.has(problem._id) ? '‚è≥ Assigning...' : 'üë• Assign Staff'}
                                  </button>
                                )}

                                {problem.status === 'assigned' && (
                                  <button
                                    className={`verify-btn ${verifying.has(problem._id) ? 'loading' : ''}`}
                                    onClick={() => handleVerify(problem._id)}
                                    disabled={verifying.has(problem._id)}
                                  >
                                    {verifying.has(problem._id) ? '‚è≥ Verifying...' : 'üì∏ Verify'}
                                  </button>
                                )}

                                {problem.status === 'verified' && (
                                  <button
                                    className={`mark-done-btn ${markingDone.has(problem._id) ? 'loading' : ''}`}
                                    onClick={() => handleMarkAsDone(problem._id)}
                                    disabled={markingDone.has(problem._id)}
                                  >
                                    {markingDone.has(problem._id) ? '‚è≥ Processing...' : '‚úÖ Mark as Done'}
                                  </button>
                                )}

                                {problem.status === 'sent_to_government' && (
                                  <span className="sent-text">üì§ Sent to Government</span>
                                )}

                                {problem.status === 'done' && (
                                  <span className="completed-text">‚úÖ Completed</span>
                                )}
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            );
          })()}
        </div>
      </div>
    </div>
  );
};
